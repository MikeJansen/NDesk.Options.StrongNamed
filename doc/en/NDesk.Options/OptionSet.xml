<Type Name="OptionSet" FullName="NDesk.Options.OptionSet">
  <TypeSignature Language="C#" Value="public class OptionSet : System.Collections.ObjectModel.Collection&lt;NDesk.Options.Option&gt;" />
  <AssemblyInfo>
    <AssemblyName>NDesk.Options</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>
    All public static members of this type are safe for multithreaded
    operations.  The 
    <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable&lt;System.String&gt;)" />
    instance method is thread-safe if no concurrent modifying methods are
    invoked (<c>Add</c>, <c>Remove</c>, etc.).
  </ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;NDesk.Options.Option&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">NDesk.Options.Option</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      A class to parse program options.
    </summary>
    <remarks>
      <para>
        Use the <see cref="T:NDesk.Options.OptionSet" /> class to associate a
        list of option names with an <paramref name="action" /> to execute 
        (either a <see cref="T:System.Action`1" /> or a 
        <see cref="T:System.Action`2" />) when the option name is encountered.
      </para>
      <para>
        There are three types of <see cref="T:NDesk.Options.Option" />s that
        can be parsed:
      </para>
      <list type="number">
        <item>
          <term>
          Boolean options, which correspond to a 
          <see cref="P:NDesk.Options.Option.OptionValueType" /> value of
          <see cref="F:NDesk.Options.OptionValueType.None" />.
          When encountered, their registered
          action is invoked immediately.  The <see cref="T:System.Action`1" />
          value will be non-<see langword="null" /> if the value is true, e.g.
          if <c>-option</c> or <c>-option+</c> is specified, and the value
          will be <see langword="null" /> if the value is false, e.g. 
          if <c>-option-</c> is specified.
        </term>
        </item>
        <item>
          <term>
          Optional value options, which correspond to a 
          <see cref="P:NDesk.Options.Option.OptionValueType" /> value of
          <see cref="F:NDesk.Options.OptionValueType.Optional" />.
          When encountered, their corresponding <see cref="T:System.Action`1" />
          is invoked when the option's value is found, which may be either
          within the current option (for <c>-option=value</c> options)
          or when the next option is encountered (for <c>-option value</c>
          options).  If there is no option value, then <see langword="null" />
          is provided as the option value.
        </term>
        </item>
        <item>
          <term>
          Required value options, which correspond to a 
          <see cref="P:NDesk.Options.Option.OptionValueType" /> value of
          <see cref="F:NDesk.Options.OptionValueType.Requried" />.
          When encountered, their corresponding <see cref="T:System.Action`1" />
          is invoked when the option's value is found, which may be either
          within the current option (for <c>-option=value</c> options)
          or when the next option is encountered (for <c>-option value</c>
          options).  If there is no option value, an 
          <see cref="T:NDesk.Options.OptionException" /> is thrown from
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />.
        </term>
        </item>
      </list>
      <block subset="none" type="behaviors">
        <para>
          Use of <c>OptionSet</c> is split up into two parts:
        </para>
        <list type="number">
          <item>
            <term>Initialization.</term>
          </item>
          <item>
            <term>Parsing.</term>
          </item>
        </list>
        <para>
          During the <paramref name="initialization" /> phase, new
          <see cref="T:NDesk.Options.Option" /> instances are created and
          associated with an action to perform when the <c>Option</c>
          requirements are met (e.g. when a required value has been
          encountered).  This phase is not thread safe.
          All options added during this phase are considered to have been
          <paramref name="registered" />.
        </para>
        <code lang="C#">OptionSet p = new OptionSet () {
  { "option-a", v =&gt; { /* action to perform */ } },
};</code>
        <para>
          There are three ways to add <see cref="T:NDesk.Options.Option" />s
          to the <see cref="T:NDesk.Options.OptionSet" />:
        </para>
        <list type="number">
          <item>
            <term>
            With C# collection initializers, as used above.
          </term>
          </item>
          <item>
            <term>
            Explicitly by calling
            <see cref="M:NDesk.Options.OptionSet.Add(System.String,System.Action{System.String})" />
            and the other <c>Add</c> overloads.
          </term>
          </item>
          <item>
            <term>
            By creating a new subclass of <see cref="T:NDesk.Options.Option" />
            and adding it via 
            <see cref="M:System.Collections.ObjectModel.Collection{NDesk.Options.Option}.Add(`0)" />.
            This is not recommended, but is available if you require more
            direct option handling than the default 
            <see cref="T:NDesk.Options.Option" /> implementation provides.
          </term>
          </item>
        </list>
        <para>
          During the <paramref name="parsing" /> phase, an
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          is parsed, looking for options which match a registered option,
          and invoking the corresponding action when an option and associated
          (optional) value is encountered.  During this phase, the 
          <see cref="T:NDesk.Options.OptionSet" /> instance itself is thread
          safe, but full thread safety depends upon thread-safety of the
          registered actions.  Any option-like strings for names that haven't
          been registered, e.g. <c>--this-was-never-registered=false</c> are
          returned from <c>Parse</c>.
        </para>
        <code lang="C#">List&lt;string&gt; extra = p.Parse (new string[]{"-option-a"});</code>
      </block>
      <block subset="none" type="overrides">
        <para>
          Subclasses can override the following <see langword="virtual" /> 
          methods to customize option parsing behavior:
        </para>
        <list type="bullet">
          <item>
            <term>
              <see cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
            </term>
          </item>
          <item>
            <term>
              <see cref="M:NDesk.Options.OptionSet.CreateOptionContext" />
            </term>
          </item>
        </list>
      </block>
    </remarks>
    <example>
      <para>
        The following example demonstrates some simple usage of 
        <see cref="T:NDesk.Options.OptionSet" />.
      </para>
      <code lang="C#" src="examples/greet.cs">using System;
using System.Collections.Generic;
using NDesk.Options;

class Test {
	static int verbosity;

	public static void Main (string[] args)
	{
		bool show_help = false;
		List&lt;string&gt; names = new List&lt;string&gt; ();
		int repeat = 1;

		var p = new OptionSet () {
			{ "n|name=", "the name of someone to greet.",
			  v =&gt; names.Add (v) },
			{ "r|repeat=", "the number of times to repeat the greeting.",
			  (int v) =&gt; repeat = v },
			{ "v", "increase debug message verbosity",
			  v =&gt; { if (v != null) ++verbosity; } },
			{ "h|help",  "show this message and exit", 
			  v =&gt; show_help = v != null },
		};

		List&lt;string&gt; extra;
		try {
			extra = p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("greet: ");
			Console.WriteLine (e.Message);
			Console.WriteLine ("Try `greet --help' for more information.");
			return;
		}

		if (show_help) {
			ShowHelp (p);
			return;
		}

		string message;
		if (extra.Count &gt; 0) {
			message = string.Join (" ", extra.ToArray ());
			Debug ("Using new message: {0}", message);
		}
		else {
			message = "Hello {0}!";
			Debug ("Using default message: {0}", message);
		}

		foreach (string name in names) {
			for (int i = 0; i &lt; repeat; ++i)
				Console.WriteLine (message, name);
		}
	}

	static void ShowHelp (OptionSet p)
	{
		Console.WriteLine ("Usage: greet [OPTIONS]+ message");
		Console.WriteLine ("Greet a list of individuals with an optional message.");
		Console.WriteLine ("If no message is specified, a generic greeting is used.");
		Console.WriteLine ();
		Console.WriteLine ("Options:");
		p.WriteOptionDescriptions (Console.Out);
	}

	static void Debug (string format, params object[] args)
	{
		if (verbosity &gt; 0) {
			Console.Write ("# ");
			Console.WriteLine (format, args);
		}
	}
}

</code>
      <para>The output (under the influence of different command-line
        arguments) is:</para>
      <code lang="sh" src="examples/greet.txt">$ mono greet.exe --help
Usage: greet [OPTIONS]+ message
Greet a list of individuals with an optional message.
If no message is specified, a generic greeting is used.

Options:
  -n, --name=VALUE           the name of someone to greet.
  -r, --repeat=VALUE         the number of times to repeat the greeting.
  -v                         increase debug message verbosity
  -h, --help                 show this message and exit

$ mono greet.exe -v- -n A -name=B --name=C /name D
Hello A!
Hello B!
Hello C!
Hello D!

$ mono greet.exe -v -n E custom greeting for: {0}
# Using new message: custom greeting for: {0}
custom greeting for: E

$ mono greet.exe -r 3 -n A
Hello A!
Hello A!
Hello A!

$ mono greet.exe -r not-an-int
greet: Could not convert string `not-an-int' to type Int32 for option `-r'.
Try `greet --help' for more information.
</code>
      <para>
        Notice how the output produced by <c>--help</c> uses the
        descriptions provided during <c>OptionSet</c> initialization.
        Notice that the <see cref="T:NDesk.Options.Option" /> requiring a 
        value (<c>n|name=</c>) can use multiple different forms of invocation,
        including: 
        <c>-n value</c>, 
        <c>-n=value</c>, 
        <c>-name value</c>, 
        <c>-name=value</c>, 
        <c>--name value</c>,
        <c>--name=value</c>,
        <c>/name value</c>, and
        <c>/name=value</c>.
      </para>
      <para>
        Notice also that the boolean <c>v</c> option can take three
        separate forms: <c>-v</c> and <c>-v+</c>, which both enable the option,
        and <c>-v-</c>, which disables the option.  (The second <c>greet</c>
        invocation uses <c>-v-</c>, which is why no debug messages are shown.)
      </para>
      <para>
        Finally, note that the action can specify a type to use.  If no type
        is provided, the action parameter will be a 
        <see cref="T:System.String" />.  If a type is provided, then
        <see cref="T:System.ComponentModel.TypeConverter" /> will be used to
        convert a string to the specified type.
      </para>
    </example>
    <example>
      <para>
        The following example shows a custom <c>OptionSet</c> subclass with
        the following additional functionality:
      </para>
      <list type="number">
        <item>
          <term>
          Option name lookup is done in a case insensitive fashion, so
          <c>--name</c> and <c>--NAME</c> are identical.
        </term>
        </item>
        <item>
          <term>
          Option-like strings cannot be used as values to options, so
          <c>--name --repeat</c> is an error.
        </term>
        </item>
        <item>
          <term>
          A key/value parser is provided, to show the use of custom 
          <see cref="T:NDesk.Options.OptionContext" /> and
          <see cref="T:NDesk.Options.Option" /> subclasses.
        </term>
        </item>
      </list>
      <code lang="C#" src="examples/subclass.cs">// Case-Insensitive OptionSet
using System;
using System.Collections.Generic;
using NDesk.Options;

class DemoOptionContext : OptionContext {
	public string OptionKey;
}

class DemoOptionSet : OptionSet {
	protected override void InsertItem (int index, Option item)
	{
		if (item.Prototype.ToLower () != item.Prototype)
			throw new ArgumentException ("prototypes must be lower-case!");
		base.InsertItem (index, item);
	}

	protected override OptionContext CreateOptionContext ()
	{
		return new DemoOptionContext ();
	}

	protected override bool Parse (string option, OptionContext c)
	{
		DemoOptionContext d = (DemoOptionContext) c;
		// Prevent --a --b
		string f, n, v;
		bool haveParts = GetOptionParts (option, out f, out n, out v);
		Option nextOption = haveParts ? GetOptionForName (n.ToLower ()) : null;
		if (haveParts &amp;&amp; c.Option != null) {
			if (nextOption == null)
				; // ignore
			else if (c.Option.OptionValueType == OptionValueType.Optional) {
				c.OptionValue = null;
				c.Option.Invoke (c);
			}
			else 
				throw new OptionException (
					string.Format ("Found option value `{0}' for option `{1}'.",
						option, c.OptionName), c.OptionName);
		}

		// option name already found, so `option' is the option value
		if (c.Option != null) {
			if (c.Option is KeyValueOption &amp;&amp; d.OptionKey == null) {
				HandleKeyValue (option, d);
				return true;
			}
			return base.Parse (option, c);
		}

		if (!haveParts)
			// Not an option; let base handle as a non-option argument.
			return base.Parse (option, c);

		// use lower-case version of the option name.
		if (nextOption != null &amp;&amp; nextOption is KeyValueOption) {
			d.Option     = nextOption;
			d.OptionName = f + n.ToLower ();
			HandleKeyValue (v, d);
			return true;
		}
		return base.Parse (f + n.ToLower () + (v != null ? "=" + v : ""), c);
	}

	static void HandleKeyValue (string option, DemoOptionContext d)
	{
		if (option == null)
			return;
		string[] parts = option.Split ('=');
		if (parts.Length == 1) {
			d.OptionKey = option;
			return;
		}
		d.OptionKey   = parts [0];
		d.OptionValue = parts [1];
		if (d.Option != null) {
			d.Option.Invoke (d);
		}
	}

	class KeyValueOption : Option {
		public KeyValueOption (string prototype, Action&lt;string,string,OptionContext&gt; action)
			: base (prototype, null)
		{
			this.action = action;
		}

		Action&lt;string,string,OptionContext&gt; action;

		protected override void OnParseComplete (OptionContext c)
		{
			DemoOptionContext d = (DemoOptionContext) c;
			action (d.OptionKey, d.OptionValue, d);
			d.OptionKey = null;
		}
	}

	public new DemoOptionSet Add (string prototype,
		Action&lt;string,string,OptionContext&gt; action)
	{
		base.Add (new KeyValueOption (prototype, action));
		return this;
	}
}

class Demo {
	public static void Main (string[] args)
	{
		bool show_help = false;
		List&lt;string&gt; names = new List&lt;string&gt; ();
		Dictionary&lt;string,string&gt; map = new Dictionary&lt;string,string&gt; ();
		int repeat = 1;

		OptionSet p = new DemoOptionSet () {
			{ "n|name=",    v =&gt; names.Add (v) },
			{ "r|repeat:",  (int v) =&gt; repeat = v },
			{ "m|map=",     (k,v,c) =&gt; map.Add (k, v) },
		};

		List&lt;string&gt; extra;
		try {
			extra = p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("subclass: ");
			Console.WriteLine (e.Message);
			return;
		}

		string message;
		if (extra.Count &gt; 0) {
			message = string.Join (" ", extra.ToArray ());
		}
		else {
			message = "Hello {0}!";
		}

		foreach (string name in names) {
			for (int i = 0; i &lt; repeat; ++i)
				Console.WriteLine (message, name);
		}
		List&lt;string&gt; keys = new List&lt;string&gt;(map.Keys);
		keys.Sort ();
		foreach (string key in keys) {
			Console.WriteLine ("Key: {0}={1}", key, map [key]);
		}
	}
}

</code>
      <para>The output (under the influence of different command-line
        arguments) is:
      </para>
      <code lang="sh" src="examples/subclass.txt">$ mono subclass.exe -n A -Name=B --NAME=C /nAMe D
Hello A!
Hello B!
Hello C!
Hello D!

$ mono subclass.exe --Repeat -name A

$ mono subclass.exe -Name --Repeat 3
subclass: Found option value `--Repeat' for option `-name'.

$ mono subclass.exe --Map a b -mAp c=d /maP=e=f
Key: a=b
Key: c=d
Key: e=f
</code>
      <para>Notice:</para>
      <list type="bullet">
        <item>
          <term>
          Notice that <c>--name</c> is treated in a case-insensitive fashion.
        </term>
        </item>
        <item>
          <term>
          That <c>repeat</c> has an optional value, so with 
          <c>--Repeat -name A</c> the default <c>int</c> value is passed (0),
          so no message is printed.
        </term>
        </item>
        <item>
          <term>
          That <c>name</c> has a required value, so 
          <c>-Name --Repeat 3</c> generates an error.
        </term>
        </item>
        <item>
          <term>
          The <c>DemoOptionSet.Add()</c> method provides appropriate key/value
          option pairs to the callback method.
        </term>
        </item>
      </list>
    </example>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OptionSet ();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          Creates and initializes a new 
          <see cref="T:NDesk.Options.OptionSet" /> class instance.
        </summary>
        <remarks>
          <para>
            This constructor causes the created 
            <see cref="T:NDesk.Options.OptionSet" /> instance to perform no
            translation of string messages; consequently, no localization is
            performed.
          </para>
        </remarks>
        <altmember cref="C:NDesk.Options.OptionSet(System.Converter{System.String,System.String})" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OptionSet (Converter&lt;string,string&gt; localizer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localizer" Type="System.Converter&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="localizer">
          A <see cref="T:System.Converter{System.String,System.String}" />
          instance that will be used to translate strings.
        </param>
        <summary>
          Creates and initializes a new 
          <see cref="T:NDesk.Options.OptionSet" /> class instance.
        </summary>
        <remarks>
          <para>
            Use this constructor when you want to perform some form of
            localization or internationalization on text strings generated
            from the <see cref="T:NDesk.Options.OptionSet" /> class.
            Generated strings include:
          </para>
          <list type="bullet">
            <item>
              <term>
              The <see cref="P:NDesk.Options.Option.Description" /> written by
              <see cref="M:NDesk.Options.OptionSet.WriteOptionDescriptions(System.Out.TextWriter)" />,
              but not the option names themselves.
            </term>
            </item>
            <item>
              <term>
              Message format strings used when an error is encountered.
            </term>
            </item>
          </list>
        </remarks>
        <example>
          <para>
            See the following example, which demonstrates how different
            localizers alter the program output.
          </para>
          <code lang="C#" src="examples/localization.cs">// Localization with NDesk.Options.OptionSet.
//
// Compile as:
//   gmcs -r:Mono.Posix.dll -r:NDesk.Options.dll code-localization.cs
using System;
using System.IO;
using Mono.Unix;
using NDesk.Options;

class LocalizationDemo {
	public static void Main (string[] args)
	{
		bool with_gettext = false;
		string useLocalizer = null;
		var p = new OptionSet () {
			{ "with-gettext", v =&gt; { useLocalizer = "gettext"; } },
			{ "with-hello",   v =&gt; { useLocalizer = "hello"; } },
			{ "with-default", v =&gt; { /* do nothing */ } },
		};
		p.Parse (args);

		Converter&lt;string, string&gt; localizer = f =&gt; f;
		switch (useLocalizer) {
			case "gettext":
				Catalog.Init ("localization", 
						Path.Combine (AppDomain.CurrentDomain.BaseDirectory,
							"locale"));
				localizer = f =&gt; { return Catalog.GetString (f); };
				break;
			case "hello":
				localizer = f =&gt; { return "hello:" + f; };;
				break;
		}

		bool help = false;
		int verbose = 0;
		bool version = false;
		p = new OptionSet (localizer) {
			{ "h|?|help", "show this message and exit.", 
				v =&gt; help = v != null },
			{ "v|verbose", "increase message verbosity.",
				v =&gt; { ++verbose; } },
			{ "n=", "must be an int",
				(int n) =&gt; { /* ignore */ } },
			{ "V|version", "output version information and exit.",
				v =&gt; version = v != null },
		};
		try {
			p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("localization: ");
			Console.WriteLine (e.Message);
			return;
		}
		if (help)
			p.WriteOptionDescriptions (Console.Out);
		if (version)
			Console.WriteLine ("NDesk.Options Localizer Demo 1.0");
		if (verbose &gt; 0)
			Console.WriteLine ("Message level: {0}", verbose);
	}
}
</code>
          <para>The output (under the influence of different command-line
            arguments) is:</para>
          <code lang="sh" src="examples/localization.txt">$ mono localization.exe --help --version
  -h, -?, --help             show this message and exit.
  -v, --verbose              increase message verbosity.
  -n=VALUE                   must be an int
  -V, --version              output version information and exit.
NDesk.Options Localizer Demo 1.0

$ LANGUAGE=es mono localization.exe --with-gettext --help --version
  -h, -?, --help             A mostrar este mensaje y salir.
  -v, --verbose              Aumento mensaje verbosidad.
  -n=VALUE                   Debe ser un int
  -V, --version              Salida de información de versión y sale.
NDesk.Options Localizer Demo 1.0

$ mono localization.exe --with-hello --help --version
  -h, -?, --help             hello:show this message and exit.
  -v, --verbose              hello:increase message verbosity.
  -nhello:=VALUE             hello:must be an int
  -V, --version              hello:output version information and exit.
NDesk.Options Localizer Demo 1.0

$ mono localization.exe -n not-an-int
localization: Could not convert string `not-an-int' to type Int32 for option `-n'.

$ mono localization.exe --with-hello -n not-an-int
localization: hello:Could not convert string `not-an-int' to type Int32 for option `-n'.
</code>
          <para>Notice:</para>
          <list type="bullet">
            <item>
              <term>
              The <c>--with-gettext</c> parser uses 
              <see cref="M:Mono.Unix.Catalog.GetString" /> to translate all
              messages
            </term>
            </item>
            <item>
              <term>
              The <c>-with-hello</c> parser prefixes all 
              descriptions with <c>hello:</c>.
            </term>
            </item>
            <item>
              <term>
              Only the descriptions are translated, and not the command-line 
              arguments themselves.  Only error messages and 
              option descriptions are translated, not the options themselves.
            </term>
            </item>
          </list>
        </example>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public NDesk.Options.OptionSet Add (NDesk.Options.Option option);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>NDesk.Options.OptionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="option" Type="NDesk.Options.Option" />
      </Parameters>
      <Docs>
        <param name="option">
          The <see cref="T:NDesk.Options.Option" /> to register.
        </param>
        <summary>
          Registers <paramref name="option" /> so that any options matching
          <see cref="M:NDesk.Options.Option.GetNames" /> will be treated
          specially by 
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />.
        </summary>
        <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
        <remarks>
          Registers each option name returned by 
          <see cref="M:NDesk.Options.Option.GetNames" />, ensuring that any
          option with a matching name will be handled by the 
          <paramref name="option" /> instance.
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="option" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public NDesk.Options.OptionSet Add (string options, Action&lt;string,NDesk.Options.OptionContext&gt; action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>NDesk.Options.OptionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.String" />
        <Parameter Name="action" Type="System.Action&lt;System.String,NDesk.Options.OptionContext&gt;" />
      </Parameters>
      <Docs>
        <param name="options">
          A <see cref="T:System.String" /> containing all option aliases to
          register and an (optional) type specifier; see
          <see cref="P:NDesk.Options.Option.Prototype" /> for details.
        </param>
        <param name="action">
          A <see cref="T:System.Action{System.String,NDesk.Options.OptionContext}" />
          to invoke when an option is parsed.
        </param>
        <summary>
          Registers each alias within <paramref name="options" /> so that any 
          options matching the aliases in <paramref name="options" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
        <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
        <remarks>
          Calls 
          <see cref="M:NDesk.Options.OptionSet.Add(System.String,System.String,System.Action{System.String,NDesk.Options.OptionContext})" />
          with a <paramref name="description" /> value of 
          <see langword="null" />.
        </remarks>
        <altmember cref="M:NDesk.Options.OptionSet.Add(System.String,System.String,System.Action{System.String,NDesk.Options.OptionContext})" />
        <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
        <exception cref="T:System.ArgumentException">
          <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="options" /> is <see langword="null" /></para>
          <para>-or-</para>
          <para>
            <paramref name="action" /> is <see langword="null" /></para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public NDesk.Options.OptionSet Add (string options, Action&lt;string&gt; action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>NDesk.Options.OptionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.String" />
        <Parameter Name="action" Type="System.Action&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="options">
          A <see cref="T:System.String" /> containing all option aliases to
          register and an (optional) type specifier; see
          <see cref="P:NDesk.Options.Option.Prototype" /> for details.
        </param>
        <param name="action">
          A <see cref="T:System.Action{System.String}" />
          to invoke when an option is parsed.
        </param>
        <summary>
          Registers each alias within <paramref name="options" /> so that any 
          options matching the aliases in <paramref name="options" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
        <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
        <remarks>
          Calls 
          <see cref="M:NDesk.Options.OptionSet.Add(System.String,System.String,System.Action{System.String})" />
          with a <paramref name="description" /> value of 
          <see langword="null" />.
        </remarks>
        <altmember cref="M:NDesk.Options.OptionSet.Add(System.String,System.String,System.Action{System.String})" />
        <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
        <exception cref="T:System.ArgumentException">
          <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="options" /> is <see langword="null" /></para>
          <para>-or-</para>
          <para>
            <paramref name="action" /> is <see langword="null" /></para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public NDesk.Options.OptionSet Add (string options, string description, Action&lt;string,NDesk.Options.OptionContext&gt; action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>NDesk.Options.OptionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="action" Type="System.Action&lt;System.String,NDesk.Options.OptionContext&gt;" />
      </Parameters>
      <Docs>
        <param name="options">
          A <see cref="T:System.String" /> containing all option aliases to
          register and an (optional) type specifier; see
          <see cref="P:NDesk.Options.Option.Prototype" /> for details.
        </param>
        <param name="description">
          A <see cref="T:System.String" /> containing to used to initialize
          the <see cref="P:NDesk.Options.Option.Description" /> property.
        </param>
        <param name="action">
          An <see cref="T:System.Action{System.String,NDesk.Options.OptionContext}" />
          to invoke when an option is parsed.
        </param>
        <summary>
          Registers each alias within <paramref name="options" /> so that any 
          options matching the aliases in <paramref name="options" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
        <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
        <remarks>
          <para>
            Use this overload when your action needs access to additional 
            <see cref="T:NDesk.Options.OptionContext" />, such as for additional
            error context reporting.
          </para>
          <para>
            The <see cref="T:NDesk.Options.OptionContext" /> provided to 
            <paramref name="action" /> is shared between all registered
            actions during the controlling 
            <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
            invocation.  Consequently, care must be taken to not modify any of
            the <see cref="T:NDesk.Options.OptionContext" /> members.
          </para>
        </remarks>
        <example>
          <para>
            The following example shows several actions which make use of the
            provided <see cref="T:NDesk.Options.OptionContext" /> parameter:
          </para>
          <code lang="C#" src="examples/context.cs">using System;
using System.ComponentModel;
using System.Globalization;
using NDesk.Options;

class FooConverter : TypeConverter {
	public override bool CanConvertFrom (ITypeDescriptorContext context, Type sourceType)
	{
		if (sourceType == typeof (string))
			return true;
		return base.CanConvertFrom (context, sourceType);
	}

	public override object ConvertFrom (ITypeDescriptorContext context,
			CultureInfo culture, object value)
	{
		string v = value as string;
		if (v != null) {
			switch (v) {
				case "A": return Foo.A;
				case "B": return Foo.B;
			}
		}

		return base.ConvertFrom (context, culture, value);
	}
}

[TypeConverter (typeof(FooConverter))]
class Foo {
	public static readonly Foo A = new Foo ("A");
	public static readonly Foo B = new Foo ("B");
	string s;
	Foo (string s) { this.s = s; }
	public override string ToString () {return s;}
}

class Test {
	public static void Main (string[] args)
	{
		Foo    f = null;
		int    n = -1;
		string s = null;
		OptionSet p = new OptionSet () {
			{ "f:", (Foo v, OptionContext c) =&gt; {
				Console.WriteLine ("# Parsed {0}; Value={1}; Index={2}",
					c.OptionName, c.OptionValue ?? "&lt;null&gt;", c.OptionIndex);
				f = v;
			} },
			{ "n=", (int v, OptionContext c) =&gt; {
				Console.WriteLine ("# Parsed {0}; Value={1}; Index={2}",
					c.OptionName, c.OptionValue, c.OptionIndex);
				n = v;
			} },
			{ "s:", (v, c) =&gt; {
				Console.WriteLine ("# Parsed {0}; Value={1}; Index={2}",
					c.OptionName, c.OptionValue, c.OptionIndex);
				s = v;
			} },
		};
		try {
			p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("context: ");
			Console.WriteLine (e.Message);
			return;
		}
		Console.WriteLine ("f={0}", f == null ? "&lt;null&gt;" : f.ToString ());
		Console.WriteLine ("n={0}", n);
		Console.WriteLine ("s={0}", s ?? "&lt;null&gt;");
	}
}
</code>
          <para>
            The following <c>sh</c> output shows the above programs behavior
            under the influence of a variety of program options.
          </para>
          <code lang="sh" src="examples/context.txt">$ mono context.exe -f
# Parsed -f; Value=&lt;null&gt;; Index=0
f=&lt;null&gt;
n=-1
s=&lt;null&gt;

$ mono context.exe -n
context: Missing required value for option '-n'.

$ mono context.exe -s
# Parsed -s; Value=; Index=0
f=&lt;null&gt;
n=-1
s=&lt;null&gt;

$ mono context.exe -f invalid
context: Could not convert string `invalid' to type Foo for option `-f'.

$ mono context.exe -n invalid
context: Could not convert string `invalid' to type Int32 for option `-n'.

$ mono context.exe -s=
# Parsed -s; Value=; Index=0
f=&lt;null&gt;
n=-1
s=

$ mono context.exe -f A --n=42 /s fourty-two
# Parsed -f; Value=A; Index=1
# Parsed --n; Value=42; Index=2
# Parsed /s; Value=fourty-two; Index=4
f=A
n=42
s=fourty-two
</code>
        </example>
        <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
        <exception cref="T:System.ArgumentException">
          <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="options" /> is <see langword="null" /></para>
          <para>-or-</para>
          <para>
            <paramref name="action" /> is <see langword="null" /></para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public NDesk.Options.OptionSet Add (string options, string description, Action&lt;string&gt; action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>NDesk.Options.OptionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="action" Type="System.Action&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="options">
          A <see cref="T:System.String" /> containing all option aliases to
          register and an (optional) type specifier; see
          <see cref="P:NDesk.Options.Option.Prototype" /> for details.
        </param>
        <param name="description">
          A <see cref="T:System.String" /> containing to used to initialize
          the <see cref="P:NDesk.Options.Option.Description" /> property.
        </param>
        <param name="action">
          A <see cref="T:System.Action{System.String}" />
          to invoke when an option is parsed.
        </param>
        <summary>
          Registers each alias within <paramref name="options" /> so that any 
          options matching the aliases in <paramref name="options" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
        <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
        <remarks>
        </remarks>
        <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
        <exception cref="T:System.ArgumentException">
          <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="options" /> is <see langword="null" /></para>
          <para>-or-</para>
          <para>
            <paramref name="action" /> is <see langword="null" /></para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public NDesk.Options.OptionSet Add&lt;T&gt; (string options, Action&lt;T,NDesk.Options.OptionContext&gt; action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>NDesk.Options.OptionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.String" />
        <Parameter Name="action" Type="System.Action&lt;T,NDesk.Options.OptionContext&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          The type of the option to parse and provide to the 
          <paramref name="action" /> callback.
        </typeparam>
        <param name="options">
          A <see cref="T:System.String" /> containing all option aliases to
          register and an (optional) type specifier; see
          <see cref="P:NDesk.Options.Option.Prototype" /> for details.
        </param>
        <param name="action">
          A <see cref="T:System.Action{``0,NDesk.Options.OptionContext}" />
          to invoke when an option is parsed.
        </param>
        <summary>
          Registers each alias within <paramref name="options" /> so that any 
          options matching the aliases in <paramref name="options" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
        <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
        <remarks>
          Calls 
          <see cref="M:NDesk.Options.OptionSet.Add``1(System.String,System.String,System.Action{``0,NDesk.Options.OptionContext})" />
          with a <paramref name="description" /> value of 
          <see langword="null" />.
        </remarks>
        <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
        <altmember cref="M:NDesk.Options.OptionSet.Add``1(System.String,System.String,System.Action{``0,NDesk.Options.OptionContext})" />
        <exception cref="T:System.ArgumentException">
          <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="options" /> is <see langword="null" /></para>
          <para>-or-</para>
          <para>
            <paramref name="action" /> is <see langword="null" /></para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public NDesk.Options.OptionSet Add&lt;T&gt; (string options, Action&lt;T&gt; action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>NDesk.Options.OptionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.String" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          The type of the option to parse and provide to the 
          <paramref name="action" /> callback.
        </typeparam>
        <param name="options">
          A <see cref="T:System.String" /> containing all option aliases to
          register and an (optional) type specifier; see
          <see cref="P:NDesk.Options.Option.Prototype" /> for details.
        </param>
        <param name="action">
          A <see cref="T:System.Action{``0}" />
          to invoke when an option is parsed.
        </param>
        <summary>
          Registers each alias within <paramref name="options" /> so that any 
          options matching the aliases in <paramref name="options" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
        <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
        <remarks>
          Calls 
          <see cref="M:NDesk.Options.OptionSet.Add``1(System.String,System.String,System.Action{``0})" />
          with a <paramref name="description" /> value of 
          <see langword="null" />.
        </remarks>
        <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
        <altmember cref="M:NDesk.Options.OptionSet.Add``1(System.String,System.String,System.Action{``0})" />
        <exception cref="T:System.ArgumentException">
          <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public NDesk.Options.OptionSet Add&lt;T&gt; (string options, string description, Action&lt;T,NDesk.Options.OptionContext&gt; action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>NDesk.Options.OptionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="action" Type="System.Action&lt;T,NDesk.Options.OptionContext&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          The type of the option to parse and provide to the 
          <paramref name="action" /> callback.
        </typeparam>
        <param name="options">
          A <see cref="T:System.String" /> containing all option aliases to
          register and an (optional) type specifier; see
          <see cref="P:NDesk.Options.Option.Prototype" /> for details.
        </param>
        <param name="description">
          A <see cref="T:System.String" /> containing to used to initialize
          the <see cref="P:NDesk.Options.Option.Description" /> property.
        </param>
        <param name="action">
          A <see cref="T:System.Action{``0,NDesk.Options.OptionContext}" />
          to invoke when an option is parsed.
        </param>
        <summary>
          Registers each alias within <paramref name="options" /> so that any 
          options matching the aliases in <paramref name="options" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
        <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
        <remarks>
          <para>
            Use this typed overload when you want strongly typed option values
            that correspond to a managed type.
            <see cref="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)" />
            is used to lookup the
            <see cref="T:System.ComponentModel.TypeConverter" /> to use when
            performing the string-to-type conversion.
          </para>
          <para>
            Use this overload when your action needs access to additional 
            <see cref="T:NDesk.Options.OptionContext" />, such as for additional
            error context reporting.
          </para>
          <para>
            The <see cref="T:NDesk.Options.OptionContext" /> provided to 
            <paramref name="action" /> is shared between all registered
            actions during the controlling 
            <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
            invocation.  Consequently, care must be taken to not modify any of
            the <see cref="T:NDesk.Options.OptionContext" /> members.
          </para>
        </remarks>
        <example>
          <para>
            The following example shows several actions which make use of the
            provided <see cref="T:NDesk.Options.OptionContext" /> parameter:
          </para>
          <code lang="C#" src="examples/context.cs">using System;
using System.ComponentModel;
using System.Globalization;
using NDesk.Options;

class FooConverter : TypeConverter {
	public override bool CanConvertFrom (ITypeDescriptorContext context, Type sourceType)
	{
		if (sourceType == typeof (string))
			return true;
		return base.CanConvertFrom (context, sourceType);
	}

	public override object ConvertFrom (ITypeDescriptorContext context,
			CultureInfo culture, object value)
	{
		string v = value as string;
		if (v != null) {
			switch (v) {
				case "A": return Foo.A;
				case "B": return Foo.B;
			}
		}

		return base.ConvertFrom (context, culture, value);
	}
}

[TypeConverter (typeof(FooConverter))]
class Foo {
	public static readonly Foo A = new Foo ("A");
	public static readonly Foo B = new Foo ("B");
	string s;
	Foo (string s) { this.s = s; }
	public override string ToString () {return s;}
}

class Test {
	public static void Main (string[] args)
	{
		Foo    f = null;
		int    n = -1;
		string s = null;
		OptionSet p = new OptionSet () {
			{ "f:", (Foo v, OptionContext c) =&gt; {
				Console.WriteLine ("# Parsed {0}; Value={1}; Index={2}",
					c.OptionName, c.OptionValue ?? "&lt;null&gt;", c.OptionIndex);
				f = v;
			} },
			{ "n=", (int v, OptionContext c) =&gt; {
				Console.WriteLine ("# Parsed {0}; Value={1}; Index={2}",
					c.OptionName, c.OptionValue, c.OptionIndex);
				n = v;
			} },
			{ "s:", (v, c) =&gt; {
				Console.WriteLine ("# Parsed {0}; Value={1}; Index={2}",
					c.OptionName, c.OptionValue, c.OptionIndex);
				s = v;
			} },
		};
		try {
			p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("context: ");
			Console.WriteLine (e.Message);
			return;
		}
		Console.WriteLine ("f={0}", f == null ? "&lt;null&gt;" : f.ToString ());
		Console.WriteLine ("n={0}", n);
		Console.WriteLine ("s={0}", s ?? "&lt;null&gt;");
	}
}
</code>
          <para>
            The following <c>sh</c> output shows the above programs behavior
            under the influence of a variety of program options.
          </para>
          <code lang="sh" src="examples/context.txt">$ mono context.exe -f
# Parsed -f; Value=&lt;null&gt;; Index=0
f=&lt;null&gt;
n=-1
s=&lt;null&gt;

$ mono context.exe -n
context: Missing required value for option '-n'.

$ mono context.exe -s
# Parsed -s; Value=; Index=0
f=&lt;null&gt;
n=-1
s=&lt;null&gt;

$ mono context.exe -f invalid
context: Could not convert string `invalid' to type Foo for option `-f'.

$ mono context.exe -n invalid
context: Could not convert string `invalid' to type Int32 for option `-n'.

$ mono context.exe -s=
# Parsed -s; Value=; Index=0
f=&lt;null&gt;
n=-1
s=

$ mono context.exe -f A --n=42 /s fourty-two
# Parsed -f; Value=A; Index=1
# Parsed --n; Value=42; Index=2
# Parsed /s; Value=fourty-two; Index=4
f=A
n=42
s=fourty-two
</code>
        </example>
        <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
        <exception cref="T:System.ArgumentException">
          <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="options" /> is <see langword="null" /></para>
          <para>-or-</para>
          <para>
            <paramref name="action" /> is <see langword="null" /></para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public NDesk.Options.OptionSet Add&lt;T&gt; (string options, string description, Action&lt;T&gt; action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>NDesk.Options.OptionSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          The type of the option to parse and provide to the 
          <paramref name="action" /> callback.
        </typeparam>
        <param name="options">
          A <see cref="T:System.String" /> containing all option aliases to
          register and an (optional) type specifier; see
          <see cref="P:NDesk.Options.Option.Prototype" /> for details.
        </param>
        <param name="description">
          A <see cref="T:System.String" /> containing to used to initialize
          the <see cref="P:NDesk.Options.Option.Description" /> property.
        </param>
        <param name="action">
          A <see cref="T:System.Action{``0}" />
          to invoke when an option is parsed.
        </param>
        <summary>
          Registers each alias within <paramref name="options" /> so that any 
          options matching the aliases in <paramref name="options" /> will be
          handled by <paramref name="action" /> during any subsequent
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          calls.
        </summary>
        <returns>
          The current <see cref="T:NDesk.Options.OptionSet" /> instance.
          This is to permit method chaining.
        </returns>
        <remarks>
          <para>
            Use this typed overload when you want strongly typed option values
            that correspond to a managed type.
            <see cref="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)" />
            is used to lookup the
            <see cref="T:System.ComponentModel.TypeConverter" /> to use when
            performing the string-to-type conversion.
          </para>
        </remarks>
        <altmember cref="M:NDesk.Options.OptionSet.Add(NDesk.Options.Option)" />
        <exception cref="T:System.ArgumentException">
          <paramref name="option" /> has an alias (as returned from
          <see cref="M:NDesk.Options.Option.GetNames" />) that conflicts with
          a previously registered <see cref="T:NDesk.Options.Option" />.
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="options" /> is <see langword="null" /></para>
          <para>-or-</para>
          <para>
            <paramref name="action" /> is <see langword="null" /></para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          Removes all <see cref="T:NDesk.Options.Option" />s from this
          instance.
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateOptionContext">
      <MemberSignature Language="C#" Value="protected virtual NDesk.Options.OptionContext CreateOptionContext ();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>NDesk.Options.OptionContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          Creates an <see cref="T:NDesk.Options.OptionContext" /> instance.
        </summary>
        <returns>
          A <see cref="T:NDesk.Options.OptionContext" /> instance to be used
          when parsing all options during the current
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          call.
        </returns>
        <remarks>
          <block subset="none" type="overrides">
            <para>
              This method can be overridden if
              <see cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
              is overridden and requires access to an 
              <see cref="T:NDesk.Options.OptionContext" /> subclass to store
              additional information during the current 
              <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
              invocation.
            </para>
          </block>
        </remarks>
        <altmember cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
        <altmember cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
      </Docs>
    </Member>
    <Member MemberName="GetOptionForName">
      <MemberSignature Language="C#" Value="protected NDesk.Options.Option GetOptionForName (string option);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>NDesk.Options.Option</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="option" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="option">
          A <see cref="T:System.String" /> containing the option name to
          lookup.
        </param>
        <summary>
          Looks up the <see cref="T:NDesk.Options.Option" /> registered to
          handle the option name <paramref name="option" />.
        </summary>
        <returns>
          The <see cref="T:NDesk.Options.Option" /> instance registered to
          handle the option name <paramref name="option" />.
          If there is no registered handler for <paramref name="option" />,
          then <see langword="null" /> is returned.
        </returns>
        <remarks>
          <para>
            Subclasses can use this function to perform 
            <paramref name="option" /> lookup when overriding
            <see cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />.
          </para>
        </remarks>
        <altmember cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="option" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetOptionParts">
      <MemberSignature Language="C#" Value="protected bool GetOptionParts (string option, out string flag, out string name, out string value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="option" Type="System.String" />
        <Parameter Name="flag" Type="System.String&amp;" RefType="out" />
        <Parameter Name="name" Type="System.String&amp;" RefType="out" />
        <Parameter Name="value" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="option">
          A <see cref="T:System.String" /> containing the option to parse into
          its constituent parts.
        </param>
        <param name="flag">
          If the method returns <see langword="true" />, a 
          <see cref="T:System.String" /> reference which contains the flag
          this option started with.  Valid flags include: <c>-</c>, <c>--</c>,
          and <c>/</c>.
        </param>
        <param name="name">
          If the method returns <see langword="true" />, a 
          <see cref="T:System.String" /> reference which will contain the
          option name following a valid <paramref name="flag" />.
          No lookup is made to determine that <paramref name="flag" /> has
          been registered via a prior 
          <see cref="M:NDesk.Options.OptionSet.Add(System.String,System.Action{System.String}" />
          or related call.
        </param>
        <param name="value">
          If the method returns <see langword="true" />, and 
          <paramref name="option" /> contains a <c>=</c>, 
          <paramref name="value" /> will contain the text after the <c>=</c>.
          Otherwise, <paramref name="value" /> will be set to 
          <see langword="null" />.
        </param>
        <summary>
          Splits <paramref name="option" /> into its constituent parts.
        </summary>
        <returns>
          A <see cref="T:System.Boolean" />; if <see langword="true" />, then
          <paramref name="flag" /> and <paramref name="name" /> will contain
          the option flag and name found within <paramref name="option" />,
          and <paramref name="value" /> will contain any string found after
          a <c>=</c> (including the empty string).
          If <see langword="false" /> is returned, <paramref name="flag" />,
          <paramref name="name" />, and <paramref name="value" /> are all
          set to <see langword="null" />.
        </returns>
        <remarks>
          Subclasses can call this method from their 
          <see cref="M:NDesk.Options.OptionSet.Parse(System.String,NDesk.Options.OptionContext" />
          method to determine whether a given string is an option, and to
          split the option up for further processing.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, NDesk.Options.Option item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="NDesk.Options.Option" />
      </Parameters>
      <Docs>
        <param name="index">
          A <see cref="T:System.Int32" /> specifying the index to insert 
          <paramref name="item" /> into.
        </param>
        <param name="item">
          The <see cref="T:NDesk.Options.Option" /> to insert.
        </param>
        <summary>
          Inserts <paramref name="item" /> at the specified 
          <paramref name="index" />.
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;string&gt; Parse (System.Collections.Generic.IEnumerable&lt;string&gt; options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="options">
          A <see cref="T:System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
          containing all options to parse.
        </param>
        <summary>
          Parses each <see cref="T:System.String" /> within 
          <paramref name="options" />, invoking any registered
          <paramref name="actions" /> if a registered option is encountered.
        </summary>
        <returns>
          A <see cref="T:System.Collections.Generic.List{System.String}" />
          containing all unhandled options.
        </returns>
        <remarks>
          <para>
            An option is unhandled if:
          </para>
          <list type="bullet">
            <item>
              <term>
              The option starts with a flag such as <c>-</c>, <c>--</c>,
              <c>/</c>, and the option name following the flag is
              unregistered.
            </term>
            </item>
            <item>
              <term>
              Or, the option does not start with a flag, and there is no prior
              parsed option that accepts a value that would use the option as
              its value.
            </term>
            </item>
          </list>
          <para>
            Furthermore, option parsing stops whenever the <c>--</c> option is
            encountered.  This is in accordance with GNU conventions, and
            is frequently used to permit users to provide option-like
            filenames, e.g. <c>ls -lF -- -l</c> to view the file <c>-l</c>
            instead of needing to use <c>ls -lF ./-l</c>.
          </para>
        </remarks>
        <exception cref="T:NDesk.Options.OptionException">
          <para>
            A value was not found for an <see cref="T:NDesk.Options.Option" />
            requiring a value.
          </para>
          <para>-or-</para>
          <para>
            An attempt was made to bundle together an option requiring a
            value.
          </para>
          <para>-or-</para>
          <para>
            An exception was generated when trying to convert the value to the
            type <typeparamref name="T" />, for options added with
            <see cref="M:NDesk.Options.OptionSet.Add``1(System.String,System.String,System.Action{``0,NDesk.Options.OptionContext})" />
            and related methods.  The originating exception is provided via
            the <see cref="P:System.Exception.InnerException" /> property.
          </para>
        </exception>
        <example>
          <para>
            The following example demonstrates some simple usage of 
            <see cref="T:NDesk.Options.OptionSet" />.
          </para>
          <code lang="C#" src="examples/greet.cs">using System;
using System.Collections.Generic;
using NDesk.Options;

class Test {
	static int verbosity;

	public static void Main (string[] args)
	{
		bool show_help = false;
		List&lt;string&gt; names = new List&lt;string&gt; ();
		int repeat = 1;

		var p = new OptionSet () {
			{ "n|name=", "the name of someone to greet.",
			  v =&gt; names.Add (v) },
			{ "r|repeat=", "the number of times to repeat the greeting.",
			  (int v) =&gt; repeat = v },
			{ "v", "increase debug message verbosity",
			  v =&gt; { if (v != null) ++verbosity; } },
			{ "h|help",  "show this message and exit", 
			  v =&gt; show_help = v != null },
		};

		List&lt;string&gt; extra;
		try {
			extra = p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("greet: ");
			Console.WriteLine (e.Message);
			Console.WriteLine ("Try `greet --help' for more information.");
			return;
		}

		if (show_help) {
			ShowHelp (p);
			return;
		}

		string message;
		if (extra.Count &gt; 0) {
			message = string.Join (" ", extra.ToArray ());
			Debug ("Using new message: {0}", message);
		}
		else {
			message = "Hello {0}!";
			Debug ("Using default message: {0}", message);
		}

		foreach (string name in names) {
			for (int i = 0; i &lt; repeat; ++i)
				Console.WriteLine (message, name);
		}
	}

	static void ShowHelp (OptionSet p)
	{
		Console.WriteLine ("Usage: greet [OPTIONS]+ message");
		Console.WriteLine ("Greet a list of individuals with an optional message.");
		Console.WriteLine ("If no message is specified, a generic greeting is used.");
		Console.WriteLine ();
		Console.WriteLine ("Options:");
		p.WriteOptionDescriptions (Console.Out);
	}

	static void Debug (string format, params object[] args)
	{
		if (verbosity &gt; 0) {
			Console.Write ("# ");
			Console.WriteLine (format, args);
		}
	}
}

</code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual bool Parse (string option, NDesk.Options.OptionContext c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="option" Type="System.String" />
        <Parameter Name="c" Type="NDesk.Options.OptionContext" />
      </Parameters>
      <Docs>
        <param name="option">
          A <see cref="T:System.String" /> containing the current option to
          parse.
        </param>
        <param name="c">
          A <see cref="T:NDesk.Options.OptionContext" /> containing the
          current parser context.
        </param>
        <summary>
          Parses <paramref name="option" /> and invokes
          <see cref="M:NDesk.Options.Option.Invoke(NDesk.Options.OptionContext)" /> 
          if appropriate.
        </summary>
        <returns>
          A <see cref="T:System.Boolean" /> specifying whether or not
          <paramref name="option" /> was handled.
          If <see langword="false" />, then
          <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
          will return <paramref name="option" /> as an unhandled option.
        </returns>
        <remarks>
          <para>
            This method is called for each <see cref="T:System.String" />
            within the <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
            provided to 
            <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />,
            which thus gives this method a chance to parse a single option, or
            chain together multiple options to form a single option (as is
            necessary when an option and its value are separated, e.g. with
            <c>-option value</c>.
          </para>
          <block subset="none" type="behaviors">
            <para>
              The default implementation will check 
              <see cref="P:NDesk.Options.OptionContext.Option" />, which is
              assumed to be a <see cref="T:NDesk.Options.Option" /> in need of
              a value.  If 
              <see cref="P:NDesk.Options.OptionContext.Option" /> is 
              non-<see langword="null" />, then
              <see cref="P:NDesk.Options.OptionContext.OptionValue" /> is set
              to <paramref name="option" /> and
              <see cref="P:NDesk.Options.Option.Invoke(NDesk.Options.OptionContext" />
              is invoked.
            </para>
            <para>
              Next, <see cref="M:NDesk.Options.OptionSet.GetOptionParts(System.String&amp;System.String&amp;,System.String&amp;)" />
              is invoked.  If <c>GetOptionParts</c> returns 
              <see langword="false" />, then <see langword="false" /> is
              returned from <c>Parse</c>.
            </para>
            <para>
              Finally, check to see if the <paramref name="name" /> returned
              from <c>GetOptionParts</c> is registered; if it is, handle it
              appropriately.  If it isn't, check to see if 
              <paramref name="name" /> is a bundled option or a boolean
              option.  If <paramref name="name" /> isn't any registered
              option, then <see langword="false" /> is returned.
              Otherwise, <see langword="true" /> is returned.
            </para>
          </block>
          <block subset="none" type="overrides">
            <para>
              Inheriting types can override this method if they want to
              customize the per-option parsing within the containing
              <see cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
              invocation.
            </para>
            <para>
              Inheriting types should consider overriding 
              <see cref="M:NDesk.Options.OptionSet.CreateOptionContext" />
              if they want to store extra information for use and retrieval
              during each <c>Parse</c> invocation.
            </para>
          </block>
        </remarks>
        <altmember cref="M:NDesk.Options.OptionSet.CreateOptionContext" />
        <altmember cref="M:NDesk.Options.OptionSet.Parse(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">
          A <see cref="T:System.Int32" /> containing the index of the 
          <see cref="T:NDesk.Options.Option" /> to remove.
        </param>
        <summary>
          Removes the <see cref="T:NDesk.Options.Option" /> at the specified
          <paramref name="index" />.
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, NDesk.Options.Option item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="NDesk.Options.Option" />
      </Parameters>
      <Docs>
        <param name="index">
          A <see cref="T:System.Int32" /> containing the index of the 
          <see cref="T:NDesk.Options.Option" /> to change.
        </param>
        <param name="item">
          The new <see cref="T:NDesk.Options.Option" /> to set at
          <paramref name="index" />.
        </param>
        <summary>
          Removes the current <see cref="T:NDesk.Options.Option" /> at 
          <paramref name="index" /> and sets <paramref name="item" /> 
          as the value for the <paramref name="index" /> value.
        </summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteOptionDescriptions">
      <MemberSignature Language="C#" Value="public void WriteOptionDescriptions (System.IO.TextWriter o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="o">
          The <see cref="T:System.IO.TextWriter" /> to write option
          descriptions to.
        </param>
        <summary>
          Writes <see cref="T:NDesk.Options.Option" /> documentation to 
          <paramref name="o" />.
        </summary>
        <remarks>
          <para>
            For each <see cref="T:NDesk.Options.Option" /> previously added to
            the current instance, this method writes out a comma-separated
            list of all <see cref="M:NDesk.Options.Option.GetNames" />
            followed by the <see cref="P:NDesk.Options.Option.Description" />.
          </para>
          <para>
            Options requiring a value have <c>=VALUE</c> appended to their
            last name, while options with an optional value have
            <c>[=VALUE]</c> appended to their last name.
          </para>
        </remarks>
        <example>
          <para>
            The following example initializes a
            <see cref="T:NDesk.Options.OptionSet" /> instance to accept a
            variety of parameters and provides a description for each
            parameter:
          </para>
          <code lang="C#" src="examples/greet.cs">using System;
using System.Collections.Generic;
using NDesk.Options;

class Test {
	static int verbosity;

	public static void Main (string[] args)
	{
		bool show_help = false;
		List&lt;string&gt; names = new List&lt;string&gt; ();
		int repeat = 1;

		var p = new OptionSet () {
			{ "n|name=", "the name of someone to greet.",
			  v =&gt; names.Add (v) },
			{ "r|repeat=", "the number of times to repeat the greeting.",
			  (int v) =&gt; repeat = v },
			{ "v", "increase debug message verbosity",
			  v =&gt; { if (v != null) ++verbosity; } },
			{ "h|help",  "show this message and exit", 
			  v =&gt; show_help = v != null },
		};

		List&lt;string&gt; extra;
		try {
			extra = p.Parse (args);
		}
		catch (OptionException e) {
			Console.Write ("greet: ");
			Console.WriteLine (e.Message);
			Console.WriteLine ("Try `greet --help' for more information.");
			return;
		}

		if (show_help) {
			ShowHelp (p);
			return;
		}

		string message;
		if (extra.Count &gt; 0) {
			message = string.Join (" ", extra.ToArray ());
			Debug ("Using new message: {0}", message);
		}
		else {
			message = "Hello {0}!";
			Debug ("Using default message: {0}", message);
		}

		foreach (string name in names) {
			for (int i = 0; i &lt; repeat; ++i)
				Console.WriteLine (message, name);
		}
	}

	static void ShowHelp (OptionSet p)
	{
		Console.WriteLine ("Usage: greet [OPTIONS]+ message");
		Console.WriteLine ("Greet a list of individuals with an optional message.");
		Console.WriteLine ("If no message is specified, a generic greeting is used.");
		Console.WriteLine ();
		Console.WriteLine ("Options:");
		p.WriteOptionDescriptions (Console.Out);
	}

	static void Debug (string format, params object[] args)
	{
		if (verbosity &gt; 0) {
			Console.Write ("# ");
			Console.WriteLine (format, args);
		}
	}
}

</code>
          <para>
            Notice that when the above program is invoked with the
            <c>--help</c> parameter, 
            <see cref="M:NDesk.Options.OptionSet.WriteOptionDescriptions" />
            is used to generate the <see cref="NDesk.Options.Option" />
            description:
          </para>
          <code lang="sh" src="examples/greet.txt">$ mono greet.exe --help
Usage: greet [OPTIONS]+ message
Greet a list of individuals with an optional message.
If no message is specified, a generic greeting is used.

Options:
  -n, --name=VALUE           the name of someone to greet.
  -r, --repeat=VALUE         the number of times to repeat the greeting.
  -v                         increase debug message verbosity
  -h, --help                 show this message and exit

$ mono greet.exe -v- -n A -name=B --name=C /name D
Hello A!
Hello B!
Hello C!
Hello D!

$ mono greet.exe -v -n E custom greeting for: {0}
# Using new message: custom greeting for: {0}
custom greeting for: E

$ mono greet.exe -r 3 -n A
Hello A!
Hello A!
Hello A!

$ mono greet.exe -r not-an-int
greet: Could not convert string `not-an-int' to type Int32 for option `-r'.
Try `greet --help' for more information.
</code>
        </example>
      </Docs>
    </Member>
  </Members>
</Type>
